游녻 user_info: 

  Sin duplicados, solo nulos en : 
  
    -last_month_salary:7199
    -number_dependents: 943

```sql
WITH total_rows AS (
  SELECT COUNT(*) AS total_rows
  FROM `riesgo-relativo-429716.dataset.user_info`
),
null_counts AS (
  SELECT
    COUNTIF(user_id IS NULL) AS user_id_nulos,
    COUNTIF(age IS NULL) AS age_nulos,
    COUNTIF(sex IS NULL) AS sex_nulos,
    COUNTIF(last_month_salary IS NULL) AS last_month_salary_nulos,
    COUNTIF(number_dependents IS NULL) AS number_dependents_nulos
  FROM `riesgo-relativo-429716.dataset.user_info`
),
duplicate_counts AS (
  SELECT
    COALESCE(CAST(user_id AS STRING), 'NULL_USER') AS user_id,
    COUNT(*) AS num_duplicates
  FROM `riesgo-relativo-429716.dataset.user_info`
  GROUP BY COALESCE(CAST(user_id AS STRING), 'NULL_USER')
  HAVING num_duplicates > 1
)
SELECT
  total_rows.total_rows,
  null_counts.user_id_nulos,
  null_counts.age_nulos,
  null_counts.sex_nulos,
  null_counts.last_month_salary_nulos,
  null_counts.number_dependents_nulos,
  duplicate_counts.user_id,
  duplicate_counts.num_duplicates
FROM
  total_rows,
  null_counts
LEFT JOIN
  duplicate_counts
ON null_counts.user_id_nulos IS NOT NULL OR duplicate_counts.user_id IS NOT NULL;
```

![image](https://github.com/user-attachments/assets/7023aad3-f36b-48a8-a4a8-99754d5cafde)

Para analizar estos nulos se creo una nueva consulta que busca analizar la relaci칩n entre el salario de los clientes y su probabilidad de incumplimiento (default). Para ello, divide a los clientes en dos grupos seg칰n tengan o no un salario registrado y luego calcula, para cada grupo, la cantidad y proporci칩n de clientes que han incumplido con sus pagos. Esto permite evaluar si la falta de informaci칩n sobre el salario es un factor relevante en la predicci칩n del riesgo crediticio. Por el momento, se mantendran 

1. La consulta (CTE):

WITH datos_unidos AS (...):  Esto es una Common Table Expression (CTE), que crea una tabla temporal llamada datos_unidos. Piensa en ella como una subconsulta que puedes referenciar m치s adelante.

SELECT ui.user_id, ui.last_month_salary, d.default_flag: La CTE selecciona tres columnas:

user_id de la tabla user_info.
last_month_salary de la tabla user_info.
default_flag de la tabla default.
FROM user_info AS ui LEFT JOIN default AS d ON ui.user_id = d.user_id:  Realiza un LEFT JOIN, que combina informaci칩n de ambas tablas bas치ndose en la coincidencia del user_id. La diferencia clave es que un LEFT JOIN incluye todas las filas de la tabla de la izquierda (user_info), incluso si no tienen coincidencias en la tabla de la derecha (default). En este caso, si un usuario no tiene un registro en default, se mostrar치 como NULL en la columna default_flag.

2. La consulta principal:

SELECT CASE WHEN last_month_salary IS NULL THEN 'Sin Salario' ELSE 'Con Salario' END AS tiene_salario:  Crea una nueva columna llamada tiene_salario que categoriza a los usuarios como "Con Salario" si tienen un valor en last_month_salary y "Sin Salario" si este valor es nulo.

default_flag: Selecciona la columna default_flag (que indica si el cliente ha incumplido).

COUNT(*) AS cantidad_clientes: Cuenta el n칰mero de filas (clientes) en cada grupo.

COUNT(*) / SUM(COUNT(*)) OVER () AS proporcion_clientes: Calcula la proporci칩n de clientes en cada grupo respecto al total.  SUM(COUNT(*)) OVER () calcula el total de clientes en todas las categor칤as, y luego cada grupo se divide por ese total.

GROUP BY tiene_salario, default_flag:  Agrupa los resultados por las columnas tiene_salario y default_flag.

ORDER BY tiene_salario, default_flag:  Ordena los resultados primero por tiene_salario y luego por default_flag.


```sql
WITH datos_unidos AS (
SELECT
먝맛i.user_id,
먝맛i.last_month_salary,
먝맋.default_flag
FROM `riesgo-relativo-429716.dataset.user_info` AS ui
LEFT JOIN `riesgo-relativo-429716.dataset.default` AS d
먝ON ui.user_id = d.user_id
)

SELECT
CASE
먝WHEN last_month_salary IS NULL THEN 'Sin Salario'
먝ELSE 'Con Salario'
END AS tiene_salario,
맋efault_flag,
COUNT(*) AS cantidad_clientes,
COUNT(*) / SUM(COUNT(*)) OVER () AS proporcion_clientes
FROM datos_unidos
GROUP BY tiene_salario, default_flag
ORDER BY tiene_salario, default_flag;
```
![image](https://github.com/user-attachments/assets/e766dc12-cea8-44be-bbbb-14e19531e9b5)

Interpretaci칩n:

* La mayor칤a de los clientes (78.47%) tienen salario registrado y no han incumplido.
* Un peque침o porcentaje (1.54%) tiene salario registrado y ha incumplido.
* Un porcentaje significativo (19.63%) no tiene salario registrado y no ha incumplido.
* Un porcentaje muy peque침o (0.36%) no tiene salario registrado y ha incumplido.

Conclusi칩n:

Esta consulta nos da una visi칩n general de c칩mo se relacionan el salario registrado (o la falta de 칠l) con el incumplimiento de los clientes. Es un buen punto de partida para un an치lisis m치s profundo del riesgo crediticio.


游눯 loans_outstanding : sin nulos

```sql
WITH null_counts_loans_outstanding AS (
  SELECT
    COUNT(*) AS total_rows,
    COUNTIF(loan_id IS NULL) AS loan_id_nulls,
    COUNTIF(user_id IS NULL) AS user_id_nulls,
    COUNTIF(loan_type IS NULL) AS loan_type_nulls
  FROM `riesgo-relativo-429716.dataset.loans_outstanding`
),
duplicate_counts_loans_outstanding AS (
  SELECT
    COALESCE(CAST(loan_id AS STRING), 'NULL_LOAN') AS loan_id,
    COALESCE(CAST(user_id AS STRING), 'NULL_USER') AS user_id,
    COUNT(*) AS num_duplicates
  FROM `riesgo-relativo-429716.dataset.loans_outstanding`
  GROUP BY COALESCE(CAST(loan_id AS STRING), 'NULL_LOAN'), COALESCE(CAST(user_id AS STRING), 'NULL_USER')
  HAVING num_duplicates > 1
)
SELECT
  null_counts_loans_outstanding.total_rows,
  null_counts_loans_outstanding.loan_id_nulls,
  null_counts_loans_outstanding.user_id_nulls,
  null_counts_loans_outstanding.loan_type_nulls,
  duplicate_counts_loans_outstanding.loan_id,
  duplicate_counts_loans_outstanding.user_id,
  duplicate_counts_loans_outstanding.num_duplicates
FROM
  null_counts_loans_outstanding
LEFT JOIN
  duplicate_counts_loans_outstanding
ON null_counts_loans_outstanding.loan_id_nulls IS NOT NULL 
OR duplicate_counts_loans_outstanding.loan_id IS NOT NULL;
```
![image](https://github.com/user-attachments/assets/668dd430-29c4-4799-8c22-3826075b4a52)


游늼 loans_detail

```sql
WITH null_counts_loans_detail AS (
  SELECT
    COUNT(*) AS total_rows,
    COUNTIF(user_id IS NULL) AS user_id_nulls,
    COUNTIF(number_times_delayed_payment_loan_30_59_days IS NULL) AS loan_identifier_nulls
  FROM `riesgo-relativo-429716.dataset.loans_detail`
),
duplicate_counts_loans_detail AS (
  SELECT
    COALESCE(CAST(user_id AS STRING), 'NULL_USER') AS user_id,
    number_times_delayed_payment_loan_30_59_days AS loan_identifier,
    COUNT(*) AS num_duplicados
  FROM
    `riesgo-relativo-429716.dataset.loans_detail`
  GROUP BY
    COALESCE(CAST(user_id AS STRING), 'NULL_USER'), loan_identifier
  HAVING
    COUNT(*) > 1
)
SELECT
  null_counts_loans_detail.total_rows,
  null_counts_loans_detail.user_id_nulls,
  null_counts_loans_detail.loan_identifier_nulls,
  duplicate_counts_loans_detail.user_id,
  duplicate_counts_loans_detail.loan_identifier,
  duplicate_counts_loans_detail.num_duplicados
FROM
  null_counts_loans_detail
LEFT JOIN
  duplicate_counts_loans_detail
ON null_counts_loans_detail.user_id_nulls IS NOT NULL OR duplicate_counts_loans_detail.user_id IS NOT NULL;
```
![image](https://github.com/user-attachments/assets/4d1dd15c-dbde-48bd-84c1-371dec81f033)


游뛀 default

```sql
WITH null_counts_default AS (
SELECT
먝COUNT(*) AS total_rows,
먝COUNTIF(user_id IS NULL) AS user_id_nulls,
먝COUNTIF(default_flag IS NULL) AS default_flag_nulls
FROM `riesgo-relativo-429716.dataset.default`
),
duplicate_counts_default AS (
SELECT
먝맛ser_id,
먝COUNT(*) AS num_duplicates
FROM `riesgo-relativo-429716.dataset.default`
GROUP BY user_id
HAVING num_duplicates > 1
)
SELECT
맕ull_counts_default.total_rows,
맕ull_counts_default.user_id_nulls,
맕ull_counts_default.default_flag_nulls,
맋uplicate_counts_default.user_id,
맋uplicate_counts_default.num_duplicates
FROM
맕ull_counts_default,
맋uplicate_counts_default;
```
![image](https://github.com/user-attachments/assets/c80a0665-3485-4c3d-9431-da3c832416cf)

